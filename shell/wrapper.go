package shell

import (
	"fmt"
	"github.com/metafates/pat/constant"
	"github.com/metafates/pat/filesystem"
	"github.com/metafates/pat/log"
	"github.com/samber/lo"
	"github.com/spf13/afero"
	"os"
	"os/exec"
	"path/filepath"
)

type Wrapper struct {
	shell instance
}

func New(shell instance) *Wrapper {
	return &Wrapper{
		shell: shell,
	}
}
func (w *Wrapper) Available() bool {
	if _, err := exec.LookPath(w.shell.Bin()); err != nil {
		return false
	}

	return true
}

func (w *Wrapper) save(script string) error {
	w.backup()

	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}

	filename := fmt.Sprintf(".%s.%s", constant.App, w.shell.Bin())
	file, err := filesystem.Api().OpenFile(filepath.Join(home, filename), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.ModePerm)
	if err != nil {
		return err
	}

	defer func(file afero.File) {
		err := file.Close()
		if err != nil {
			log.Warn(err)
		}
	}(file)

	script = fmt.Sprintf(`%[1]s Generated by %[2]s %[3]s
%[1]s https://github.com/metafates/%[2]s
%[1]s Do not edit this file manually, let %[2]s handle it for you :)

%[4]s
`, w.shell.CommentToken(), constant.App, constant.Version, script)

	_, err = file.WriteString(script)
	return err
}

func (w *Wrapper) AddPath(path string) error {
	paths, err := w.Paths()
	if err != nil {
		return err
	}

	// prepend to paths
	paths = append([]string{path}, paths...)

	return w.save(w.shell.GenerateExport(paths))
}

func (w *Wrapper) RemovePath(path string) error {
	paths, err := w.Paths()
	if err != nil {
		return err
	}

	paths = lo.Filter(paths, func(p string, _ int) bool {
		return p != path
	})

	return w.save(w.shell.GenerateExport(paths))
}

func (w *Wrapper) Export(paths []string) error {
	return w.save(w.shell.GenerateExport(paths))
}

func (w *Wrapper) Paths() ([]string, error) {
	return w.shell.Paths()
}

func (w *Wrapper) Name() string {
	return w.shell.Name()
}

func (w *Wrapper) IsDefault() bool {
	defaultShell := filepath.Clean(os.Getenv("SHELL"))
	p, _ := w.BinPath()
	return p == defaultShell
}

func (w *Wrapper) BinPath() (string, error) {
	return exec.LookPath(w.shell.Bin())
}
